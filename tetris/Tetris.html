<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shaderboy Export</title>
    <style>
        body {
            text-align: center;
        }
        #render-canvas {
            width: 1200px;
            height: 800px;
            margin: 1em;
            display: inline-block;
        }

        .shaderboy.overlay {
            z-index: 5;
            font-size: 150%;
            background-color: rgba(255, 255, 255, 0.75);
            color: #222;
            border: 2px solid gray;
            border-radius: 15%;
            padding: 0px 5px;
            margin: 2px;
            cursor: default;
        }

        .shaderboy#fps {
            padding: 4px 7.5px 5px 7.5px;
            position: absolute;
            top: 0;
            left: 0;
        }

        .shaderboy.button {
            cursor: pointer;
            font-weight: 200%;
            padding: 0.1em 0;
        }

        .shaderboy.button:hover {
            background-color: rgba(255, 255, 255, 1);
        }

        .shaderboy.content {
            position: relative;
            display: inline-block;
        }

        .shaderboy.ui {
            position: absolute;
            width: 100%;
            bottom: 0;
            left: 0;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            transition: 0.1s;
        }
    </style>
</head>
<body>
    <div id='render-canvas'></div>
</body><script type='text/javascript'>!function(e){"use strict";class ShaderProgram{constructor(e){this.gl=e,this.program=e.createProgram(),this.attrib=null,this.uniform=null,this._firstUse=!0,this._vertexShader=null,this._fragmentShader=null}deleteProgram(){const e=this.gl;this.program&&(e.deleteShader(this._vertexShader),e.deleteShader(this._fragmentShader),e.deleteProgram(this.program)),this.program=e.createProgram(),this.attrib=null,this.uniform=null,this._firstUse=!0,this._vertexShader=null,this._fragmentShader=null}updateShaderSource(e){const t=this.gl;this._firstUse=!0,null===this.program&&(this.program=t.createProgram(),t.attachShader(this.program,this._vertexShader),t.attachShader(this.program,this._fragmentShader)),t.shaderSource(this._fragmentShader,e),t.compileShader(this._fragmentShader)}attachShaderSource(e,t){const s=this.gl;let r;switch(t){case s.VERTEX_SHADER:this._vertexShader=s.createShader(t),r=this._vertexShader;break;case s.FRAGMENT_SHADER:this._fragmentShader=s.createShader(t),r=this._fragmentShader;break;default:return void alert("Invalid Shader Type:",t)}s.attachShader(this.program,r),s.shaderSource(r,e),s.compileShader(r)}attachShaderSourceFromXHR(e,t){var s=this;return new Promise((function(r,i){var a=new XMLHttpRequest;a.addEventListener("load",(function(e){200==a.status?(s.attachShaderSource(a.response,t),r()):i(a.statusText)}),!1),a.open("GET",e,!0),a.send(null)}))}attachShaderSourceFromTag(e,t){var s=document.querySelector(e);if(s){for(var r="",i=s.firstChild;i;)3==i.nodeType&&(r+=i.textContent),i=i.nextSibling;this.attachShaderSource(r,t)}else console.error("Shader source tag not found:",e)}bindAttribLocation(e){const t=this.gl;if(e){this.attrib={};for(const s in e)t.bindAttribLocation(this.program,e[s],s),this.attrib[s]=e[s]}}link(){this.gl.linkProgram(this.program)}use(){const e=this.gl;if(this._firstUse){if(e.getProgramParameter(this.program,e.LINK_STATUS)){if(!this.attrib){this.attrib={};const t=e.getProgramParameter(this.program,e.ACTIVE_ATTRIBUTES);for(let s=0;s<t;s++){const t=e.getActiveAttrib(this.program,s);this.attrib[t.name]=e.getAttribLocation(this.program,t.name)}}this.uniform={};const t=e.getProgramParameter(this.program,e.ACTIVE_UNIFORMS);for(let s=0;s<t;s++){const t=e.getActiveUniform(this.program,s);this.uniform[t.name]=e.getUniformLocation(this.program,t.name)}}else this._vertexShader&&!e.getShaderParameter(this._vertexShader,e.COMPILE_STATUS)?alert("Vertex shader compile error:"+e.getShaderInfoLog(this._vertexShader)):this._fragmentShader&&!e.getShaderParameter(this._fragmentShader,e.COMPILE_STATUS)?alert("Fragment shader compile error:"+e.getShaderInfoLog(this._fragmentShader)):alert("Program link error:"+e.getProgramInfoLog(this.program)),e.deleteProgram(this.program),this.program=null;this._firstUse=!1}e.useProgram(this.program)}}class FPSCounter{constructor(e,t=30){this.values=[],this.limit=t,this.prev=0,this.index=0,this.elem=document.createElement("span"),this.elem.id="fps",this.elem.classList.add("shaderboy"),this.elem.classList.add("overlay"),e.appendChild(this.elem),this.elem.innerHTML=0}update(e){this.prev||(this.prev=e);const t=e-this.prev;return this.values.length<this.limit?this.values.push(t):(this.values[this.index]=t,this.index=(this.index+1)%this.limit),this.prev=e,this.elem.innerHTML=Math.floor(this.fps),t}clear(){this.values=[],this.prev=0,this.index=0,this.elem&&(this.elem.innerHTML=0)}get fps(){return 1e3/(this.values.reduce((e,t)=>e+t,0)/this.values.length)}}const t={fullscreen:!0,font:{}},s="#version 300 es\n        precision mediump float;\n\n        in vec3 iPosition;\n\n        void main()\n        {\n            gl_Position = vec4(iPosition, 1.0);\n        }",r=[{type:"2fv",name:"uResolution",callback:function(e){return[e.width,e.height]}},{type:"1f",name:"uTime",callback:function(e){return e.time}},{type:"1f",name:"uDeltaTime",callback:function(e){return e.deltaTime}},{type:"2fv",name:"uMouse",callback:function(e){return[e.mouse.x,e.mouse.y]}},{type:"2fv",name:"uMouseClick",callback:function(e){return[e.mouse.clickX,e.mouse.clickY]}},{type:"2fv",name:"uMouseButtons",callback:function(e){return[e.mouse.down[0]?1:0,e.mouse.down[1]?1:0]}}];class Renderer{constructor(e,r,i=t){this.vertSrc=s,this.fragSrc=r,this.inputSrc={},this.program=null,this.settings=Object.create(t),Object.assign(this.settings,i),this.callbacks=[],this.permaCallbacks=[],this.pauseCallbacks=[],this.resizeCallbacks=[],this.keyCallbacks={down:[],up:[]},this.mouseCallbacks={down:[],up:[],move:[],enter:[],out:[],wheel:[]},this.debug={},this.loop=null,this.pause=!1,this.uniforms=[],this.matrices=[],this.time=0,this.deltaTime=0,this.clearColor=[0,0,0,0],this.keys={},this.mouse={x:0,y:0,clickX:0,clickY:0,down:[!1,!1]},this.parent=document.getElementById(e),this.parent.classList.add("shaderboy"),this.parent.classList.add("content"),this.canvas=document.createElement("canvas"),this.canvas.classList.add("shaderboy"),this.canvas.tabIndex=1,this.canvas.style.outline="none",this.parent.appendChild(this.canvas),this.fps=new FPSCounter(this.parent),this.addEventListener()}get width(){return this.canvas.clientWidth}get height(){return this.canvas.clientHeight}reset(){this.time=0,this.deltaTime=0}addEventListener(){const e=document.createElement("div");e.classList.add("shaderboy"),e.classList.add("ui"),this.canvas.addEventListener("keydown",e=>{this.keys[e.key]=!0,this.keys[e.code]=!0,this.keyCallbacks.down.forEach(t=>t(e,this))}),this.canvas.addEventListener("keyup",e=>{this.keys[e.key]=!1,this.keys[e.code]=!1,this.keyCallbacks.up.forEach(t=>t(e,this))});const t=document.createElement("span");if(this.settings.font.pause?t.classList.add(this.settings.font.pause):t.innerHTML="&#x23ef;",t.classList.add("shaderboy","overlay","button"),t.addEventListener("click",()=>{this.togglePause(),this.settings.font.play&&this.settings.font.pause&&(t.classList.remove(this.settings.font[this.pause?"pause":"play"]),t.classList.add(this.settings.font[this.pause?"play":"pause"]))}),e.appendChild(t),this.settings.fullscreen){this.parent.addEventListener("fullscreenchange",()=>{this.resize()});const t=document.createElement("span");this.settings.font.fullscreen?t.classList.add(this.settings.font.fullscreen):t.innerHTML="&#9974;",t.classList.add("shaderboy","overlay","button"),t.style.marginLeft="auto",t.style.order=100,t.addEventListener("click",this.toggleFullscreen.bind(this)),e.appendChild(t)}this.parent.appendChild(e),new ResizeObserver(()=>{this.resize()}).observe(this.parent),this.canvas.addEventListener("mousemove",e=>{const t=this.canvas.getBoundingClientRect();this.mouse.x=Math.floor(e.clientX-t.left),this.mouse.y=Math.floor(e.clientY-t.top),this.mouse.down[0]=1==e.buttons,this.mouse.down[1]=2==e.buttons,this.mouseCallbacks.move.forEach(t=>t(e,this))}),this.canvas.addEventListener("mouseenter",e=>{this.mouseCallbacks.enter.forEach(t=>t(e,this))}),this.canvas.addEventListener("mouseout",e=>{this.mouseCallbacks.out.forEach(t=>t(e,this))}),this.canvas.addEventListener("mousedown",e=>{const t=this.canvas.getBoundingClientRect();this.mouse.down[0]=1==e.buttons,this.mouse.down[1]=2==e.buttons,this.mouse.clickX=Math.floor(e.clientX-t.left),this.mouse.clickY=Math.floor(e.clientY-t.top),this.mouseCallbacks.down.forEach(t=>t(e,this))}),this.canvas.addEventListener("mouseup",e=>{this.mouse.down[0]=1==e.buttons,this.mouse.down[1]=2==e.buttons,this.mouseCallbacks.up.forEach(t=>t(e,this))}),this.canvas.addEventListener("wheel",e=>{this.mouseCallbacks.wheel.forEach(t=>t(e,this))})}init(){try{this.gl=this.canvas.getContext("webgl2",{preserveDrawingBuffer:!0})}catch(e){}this.gl?(this.gl.clearColor(...this.clearColor),this.createScreenQuad(),this.setupShader(),r.forEach(e=>{this.addUniform(e.type,e.name,e.callback)}),this.resize()):e.alert("Error: Could not create WebGL2 Context")}restart(){this.program.deleteProgram(),this.program=null,this.callbacks=[],this.pauseCallbacks=[],this.resizeCallbacks=[],this.keyCallbacks={down:[],up:[]},this.mouseCallbacks={down:[],up:[],move:[],enter:[],out:[],wheel:[]},this.debug={},this.loop&&e.cancelAnimationFrame(this.loop),this.loop=null,this.pause=!1,this.uniforms=[],this.matrices=[],this.keys={},this.time=0,this.deltaTime=0,this.mouse={x:0,y:0,clickX:0,clickY:0,down:[!1,!1]},this.fps.clear(),this.init(),this.start()}render(t){const s=this.gl;this.time+=.01,Number.isNaN(this.time)&&(this.time=0),this.deltaTime=this.fps.update(t)/1e3,this.program.use(),null!==this.program.program&&(s.bindBuffer(s.ARRAY_BUFFER,this.buffer),this.setUniforms(t),this.permaCallbacks.forEach(e=>e(this,t)),this.callbacks.forEach(e=>e(this,t)),s.drawArrays(s.TRIANGLES,0,6)),this.loop=e.requestAnimationFrame(this.render.bind(this))}start(){null===this.loop&&(this.loop=e.requestAnimationFrame(this.render.bind(this)))}addButton(e="",t=""){const s=document.createElement("span");s.innerHTML=e,s.classList.add("shaderboy","overlay","button"),s.classList.add(...t);const r=document.querySelector("div.shaderboy.ui");return r?(r.appendChild(s),s):null}togglePause(){this.pause=!this.pause,this.pause?(e.cancelAnimationFrame(this.loop),this.loop=null):this.loop=e.requestAnimationFrame(this.render.bind(this)),this.pauseCallbacks.forEach(e=>e(this,this.pause))}addCallback(e){this.callbacks.push(e)}addResizeCallback(e){this.resizeCallbacks.push(e)}addPermanentCallback(e){this.permaCallbacks.push(e)}addMouseCallback(e,t){this.mouseCallbacks[e].push(t)}addKeyCallback(e,t){this.keyCallbacks[e].push(t)}addPauseCallback(e){this.pauseCallbacks.push(e)}save(e){return this.canvas.toDataURL("image/jpeg",e)}setUniforms(e){this.uniforms.forEach(t=>{const s=this.program.uniform[t.name];"function"==typeof t.callback?this.debug[t.name]=t.callback(this,e,this.time):this.debug[t.name]=t.callback,void 0!==s&&(!t.multiple||t.asArray?(this.gl[`uniform${t.type}`](s,this.debug[t.name]),t.texture&&(this.gl.activeTexture(this.gl.TEXTURE0+this.debug[t.name]),this.gl.bindTexture(t.target,t.texture))):this.gl[`uniform${t.type}`](s,...this.debug[t.name]))}),this.matrices.forEach(t=>{const s=this.program.uniform[t.name];"function"==typeof t.callback?this.debug[t.name]=t.callback(this,e,this.time):this.debug[t.name]=t.callback,void 0!==s&&this.gl[`uniformMatrix${t.type}`](s,t.transpose,this.debug[t.name],t.srcOffset,t.srcLength)})}addUniform(e,t,s,r=null,i=this.gl.TEXTURE_2D){const a={type:e,name:t,callback:s,texture:r,target:i};Number.parseInt(e[0])>1&&(a.multiple=!0),"v"===e[e.length-1]&&(a.asArray=!0),this.uniforms.push(a)}uniformValues(){return this.debug}addMatrix(e,t,s,r,i,a){this.matrices.push({type:e,name:t,callback:s,transpose:r,srcOffset:i,srcLength:a})}addInput(e,t){this.inputSrc[e]=t}resize(){this.canvas.width=this.parent.clientWidth,this.canvas.height=this.parent.clientHeight,this.gl&&this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.resizeCallbacks.forEach(e=>e(this,this.canvas.width,this.canvas.height))}toggleFullscreen(){document.fullscreenEnabled?document.fullscreenElement?document.exitFullscreen().catch(()=>console.error("Your are now trapped")):this.parent.requestFullscreen().catch(()=>console.error("Sorry, could not enter fullscreen =(")):alert("This document does not support fullscreen!")}createScreenQuad(){if(!this.buffer){const e=this.gl;this.buffer=e.createBuffer();const t=new Float32Array([-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0,1,1,0]);e.bindBuffer(e.ARRAY_BUFFER,this.buffer),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}}updateFragmentShader(e){return this.fragSrc=this.parseShader(e),this.program.updateShaderSource(this.fragSrc),this.program.link(),{succes:"yay"}}getFragmentShader(){return console.log(this.fragSrc),this.parseShader(this.fragSrc)}getVertexShader(){return this.vertSrc}parseShader(e){let t;do{if((t=e.match(/#include <(\w+)>\n/))&&2==t.length){const s=t[0],r=t[1];e=e.replace(s,this.inputSrc[r])}}while(t);return e}setupShader(){const e=this.gl;this.program=new ShaderProgram(e),this.program.attachShaderSource(this.vertSrc,e.VERTEX_SHADER),this.program.attachShaderSource(this.parseShader(this.fragSrc),e.FRAGMENT_SHADER),this.program.link();const t=3*Float32Array.BYTES_PER_ELEMENT;e.vertexAttribPointer(0,3,e.FLOAT,!1,t,0),e.enableVertexAttribArray(0)}}e.shaderboy=new class ShaderBoy{constructor(){this.renderer=null}get valid(){return null!=this.renderer}create(e,s,r=t){this.renderer=new Renderer(e,s,r)}restart(){this.valid&&this.renderer.restart()}init(){this.valid&&this.renderer.init()}reset(){this.valid&&this.renderer.reset()}run(){this.valid&&this.renderer.start()}pause(){this.valid&&this.renderer.togglePause()}isPaused(){if(this.valid)return!0===this.renderer.pause}onPause(e){this.valid&&this.renderer.addPauseCallback(e)}gl(){if(this.valid)return this.renderer.gl}canvas(){if(this.valid)return this.renderer.canvas}save(e=.5){if(this.valid)return this.renderer.save(Math.max(0,Math.min(1,e)))}key(e){if(this.valid)return void 0!==this.renderer.keys[e]&&!0===this.renderer.keys[e]}keyCode(e){if(this.valid)return void 0!==this.renderer.keys[e]&&!0===this.renderer.keys[e]}fullscreen(){this.valid&&this.renderer.toggleFullscreen()}onMouse(e,t){if(this.valid)switch(e){case"up":case"down":case"move":case"out":case"wheel":this.renderer.addMouseCallback(e,t)}}onMouseUp(e){this.valid&&this.renderer.addMouseCallback("up",e)}onMouseDown(e){this.valid&&this.renderer.addMouseCallback("down",e)}onMouseMove(e){this.valid&&this.renderer.addMouseCallback("move",e)}onMouseEnter(e){this.valid&&this.renderer.addMouseCallback("enter",e)}onMouseOut(e){this.valid&&this.renderer.addMouseCallback("out",e)}onMouseWheel(e){this.valid&&this.renderer.addMouseCallback("wheel",e)}onKey(e,t){if(this.valid)switch(e){case"up":case"down":this.renderer.addKeyCallback(e,t)}}onKeyUp(e){this.valid&&this.renderer.addKeyCallback("up",e)}onKeyDown(e){this.valid&&this.renderer.addKeyCallback("down",e)}addPermanentFrameCallback(e){this.valid&&this.renderer.addPermanentCallback(e)}addFrameCallback(e){this.valid&&this.renderer.addCallback(e)}addResizeCallback(e){this.valid&&this.renderer.addResizeCallback(e)}clearCallbacks(){this.valid&&(this.renderer.callbacks=[],this.renderer.resizeCallbacks=[],this.renderer.mouseCallbacks.up=[],this.renderer.mouseCallbacks.down=[],this.renderer.mouseCallbacks.move=[],this.renderer.mouseCallbacks.enter=[],this.renderer.mouseCallbacks.out=[],this.renderer.mouseCallbacks.wheel=[],this.renderer.keyCallbacks.up=[],this.renderer.keyCallbacks.down=[])}setShader(e){if(this.valid)return this.renderer.updateFragmentShader(e)}getShader(e="fs"){if(this.valid)switch(e){case"vs":case"VS":return this.renderer.getVertexShader();case"fs":case"FS":default:return this.renderer.getFragmentShader()}}addShaderInput(e,t){this.valid&&this.renderer.addInput(e,t)}addUniform1f(e,t){this.valid&&this.renderer.addUniform("1f",e,t)}addUniform1fv(e,t){this.valid&&this.renderer.addUniform("1fv",e,t)}addUniform1i(e,t,s,r){this.valid&&this.renderer.addUniform("1i",e,t,s,r)}addUniform1iv(e,t){this.valid&&this.renderer.addUniform("1iv",e,t)}addUniform2f(e,t){this.valid&&this.renderer.addUniform2fv("2f",e,t)}addUniform2fv(e,t){this.valid&&this.renderer.addUniform("2fv",e,t)}addUniform2i(e,t){this.valid&&this.renderer.addUniform("2i",e,t)}addUniform2iv(e,t){this.valid&&this.renderer.addUniform("2iv",e,t)}addUniform3f(e,t){this.valid&&this.renderer.addUniform("3f",e,t)}addUniform3fv(e,t){this.valid&&this.renderer.addUniform("3fv",e,t)}addUniform3i(e,t){this.valid&&this.renderer.addUniform("3i",e,t)}addUniform3iv(e,t){this.valid&&this.renderer.addUniform("3iv",e,t)}addUniform4f(e,t){this.valid&&this.renderer.addUniform("4f",e,t)}addUniform4fv(e,t){this.valid&&this.renderer.addUniform("4fv",e,t)}addUniform4i(e,t){this.valid&&this.renderer.addUniform("4i",e,t)}addUniform4iv(e,t){this.valid&&this.renderer.addUniform("4iv",e,t)}addUniformMatrix2fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("2fv",e,t,s,r,i)}addUniformMatrix3x2fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("3x2fv",e,t,s,r,i)}addUniformMatrix4x2fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("4x2fv",e,t,s,r,i)}addUniformMatrix3fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("3fv",e,t,s,r,i)}addUniformMatrix2x3fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("2x3fv",e,t,s,r,i)}addUniformMatrix4x3fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("4x3fv",e,t,s,r,i)}addUniformMatrix4fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("4fv",e,t,s,r,i)}addUniformMatrix2x4fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("2x4fv",e,t,s,r,i)}addUniformMatrix3x4fv(e,t,s,r,i){this.valid&&this.renderer.addMatrix("3x4fv",e,t,s,r,i)}}}(window);</script>

<script type='text/javascript'> function external() {
// MAIN JS
/**
 * Author: René Warnking
 * Copyright 2019 René Warnking
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

///////////////////////////////////////////////////
// Keybindings
///////////////////////////////////////////////////
const KEY_RESTART = 'KeyR';
const KEY_RIGHT = 'KeyD';
const KEY_LEFT = 'KeyA';
const KEY_DOWN = 'KeyS';
const KEY_FULLDOWN = 'Space';
const KEY_TLEFT = 'KeyQ';
const KEY_TRIGHT = 'KeyE';

///////////////////////////////////////////////////
// Setup
///////////////////////////////////////////////////
const width = 8;
if (width % 4 != 0)
    console.alert("Width should be 4 aligned");
const height = 12;
// TODO ?!
if (height % 2 != 0)
    console.alert("Height should be even");
let data = new Uint8Array(width * height);

// fill with random data (max 255)
for (let i = 0; i < height; i++) {
    for (let j = 0; j < width; j++) {
        //data[i * width + j] = Math.floor(Math.random() * Math.floor(255));
        data[i * width + j] = 0;
    }
}

const directions = Object.freeze({
    left: 0,
    right: 1,
    down: 2,
    downMax: 3
});

const rotations = Object.freeze({
    left: 0,
    right: 1
});

function isEmpty(pos) {
    return data[stone_pos_Y * width + pos] === 0;
}

const effect = {
    time: 0,
    direction: 1
};

///////////////////////////////////////////////////
// Uniforms
///////////////////////////////////////////////////
shaderboy.addUniform1i("uBoardTex", 0);
shaderboy.addUniform1f("uWidth", width);
shaderboy.addUniform1f("uHeight", height);
shaderboy.addUniform3fv("uCameraPos", [0.0, 0.0, 0.0]);
shaderboy.addUniform1f("uEffectTime", () => effect.time);

///////////////////////////////////////////////////
// Movement functions
///////////////////////////////////////////////////
function shiftStone(direction) {
    if (gameEnd)
        return;

	switch (direction) {
        case directions.left : {
            deleteStoneFromArray();
            stone_pos_X--;
            if (!checkIfAllowed()) {
            	stone_pos_X++;
            }
            addStoneToArray();
            break;
        }
        case directions.right : {
            deleteStoneFromArray();
            stone_pos_X++;
            if (!checkIfAllowed()) {
            	stone_pos_X--;
            }
            addStoneToArray();
            break;
        }
        case directions.down : {
            deleteStoneFromArray();
            stone_pos_Y--;
            if (!checkIfAllowed()) {
            	stone_pos_Y++;
            }
            addStoneToArray();
            break;
        }
        case directions.downMax : {
            deleteStoneFromArray();
            do {
            	stone_pos_Y--;
            } while(checkIfAllowed());
            stone_pos_Y++;
            addStoneToArray();
            t = speed;
            break;
        }
        default: break;
    }
}

// TODO objects can be rotated inside other ones - add corresponding checks
function rotateStone(rotate) {
    if (gameEnd)
        return;
    deleteStoneFromArray();

    let tmp = stoneArray;
    // TODO: in-place
    if (rotate == rotations.right) {
        let result = [];
        for (let i = 0; i < stoneArray[0].length; i++) {
            let row = stoneArray.map(e => e[i]).reverse();
            result.push(row);
        }
        stoneArray = result;
    } else if (rotate == rotations.left) {
        let result = [];
        for (let i = stoneArray[0].length-1; i >= 0; i--) {
            let row = stoneArray.map(e => e[i]);
            result.push(row);
        }
        stoneArray = result;
    }

    if (!checkIfAllowed()) {
		stoneArray = tmp;
    }
    addStoneToArray();
}

///////////////////////////////////////////////////
// Select the stone and fill up the Stone Array
///////////////////////////////////////////////////
const stoneArrayWidth = 4;
const stoneArrayHeight = 4;
//let stoneArray = new Uint8Array(stoneArrayWidth * stoneArrayHeight);
let stoneArray = [[]];

const stoneTypes = Object.freeze({
    size: 11,
    bar2: 0,
    bar3: 1,
    bar4: 2,
    J: 3,
    L: 4,
    cube: 5,
    smallL: 6,
    T: 7,
    plus: 8,
    S: 9,
    Z: 10
});

function fillWithRandomStone() {
    let stoneType = Math.floor(Math.random() * Math.floor(stoneTypes.size));
    const stoneColor = Math.floor(Math.random() * Math.floor(254)) + 1;

    switch (stoneType) {
        case stoneTypes.bar2 : {
            stoneArray = [[stoneColor, stoneColor]];
            break;
        }
        case stoneTypes.bar3 : {
            stoneArray = [[stoneColor, stoneColor, stoneColor]];
            break;
        }
        case stoneTypes.bar4 : {
            stoneArray = [[stoneColor, stoneColor, stoneColor, stoneColor]];
            break;
        }
        case stoneTypes.J : {
            stoneArray = [
                [stoneColor, 0, 0],
                [stoneColor, stoneColor, stoneColor]
            ];
            break;
        }
        case stoneTypes.L : {
            stoneArray = [
                [stoneColor, stoneColor, stoneColor],
                [stoneColor, 0, 0]
            ];
            break;
        }
        case stoneTypes.cube : {
            stoneArray = [
                [stoneColor, stoneColor],
                [stoneColor, stoneColor]
            ];
            break;
        }
        case stoneTypes.smallL : {
            stoneArray = [
                [stoneColor, stoneColor],
                [stoneColor, 0]
            ];
            break;
        }
        case stoneTypes.T : {
            stoneArray = [
                [stoneColor, stoneColor, stoneColor],
                [0, stoneColor, 0]
            ];
            break;
        }
        case stoneTypes.plus : {
            stoneArray = [
                [0, stoneColor, 0],
                [stoneColor, stoneColor, stoneColor],
                [0, stoneColor, 0],
            ];
            break;
        }
        case stoneTypes.S : {
            stoneArray = [
                [0, stoneColor, stoneColor],
                [stoneColor, stoneColor, 0]
            ];
            break;
        }
        case stoneTypes.Z : {
            stoneArray = [
                [stoneColor, stoneColor, 0],
                [0, stoneColor, stoneColor]
            ];
            break;
        }
    }
}

function deleteStoneFromArray() {
    for (let y = 0; y < stoneArray.length; y++) {
        for (let x = 0; x < (stoneArray[y]).length; x++) {
            if (stoneArray[y][x] > 0) {
            	data[(stone_pos_Y - y) * width + stone_pos_X + x] = 0;
            }
        }
    }
}

function addStoneToArray() {
    for (let y = 0; y < stoneArray.length; y++) {
        for (let x = 0; x < (stoneArray[y]).length; x++) {
            if (stoneArray[y][x] > 0) {
            	data[(stone_pos_Y - y) * width + stone_pos_X + x] = stoneArray[y][x];
            }
        }
    }
}

///////////////////////////////////////////////////
// Rule-Check functions
///////////////////////////////////////////////////
function checkIfAllowed() {
    if (stone_pos_X + stoneArray[0].length > width ||
        stone_pos_X < 0 ||
        stone_pos_Y - stoneArray.length < 0
       )
        return false;

    for (let y = 0; y < stoneArray.length; y++) {
        for (let x = 0; x < (stoneArray[y]).length; x++) {
            if (stoneArray[y][x] > 0) {
            	if (data[(stone_pos_Y - y) * width + stone_pos_X + x] > 0)
                    return false;
            }
        }
    }
    return true;
}

// TODO is this method still necessary?
function checkBelowStone() {
    let result = true;
    // loop every column and check for lowest stone part to compare with field below
    // length should be the same for all arrays
    for (let x = 0; x < (stoneArray[0]).length; x++) {
    	let y = stoneArray.length - 1;
        for (; stoneArray[y][x] === 0; y--);

        // TODO shouldnt the first case be clear with one check, because there only
        // needs to be one entry in the last line
        if (stone_pos_Y - y - 1 === -1) {
            return false;
        } else if (
            data[(stone_pos_Y - y - 1) * width + stone_pos_X + x] > 0) {
        	return false;
        }
    }

	return result;
}

///////////////////////////////////////////////////
// Progress functions
///////////////////////////////////////////////////
function emitStone() {
    fillWithRandomStone();
	stone_pos_X = width / 2.0 - Math.round(stoneArray[0].length / 2.0);
    stone_pos_Y = height - 1;
}

let gameEnd = false;
function gameOver() {
    if (gameEnd)
        return gameEnd;
	for (let x = 0; x < width; x++) {
        if (data[(height - 1) * width + x] > 0) {
            gameEnd = true;
            return true;
        }
    }
    return false;
}

function clearLine(y) {
    for (let x = 0; x < width; x++) {
        data[y * width + x] = 0;
    }
}

function shiftLines(_y) {
    for (let y = _y; y < height - 1; y++) {
        for (let x = 0; x < width; x++) {
            data[y * width + x] = data[(y + 1) * width + x];
        }
    }
}

function ifLineCompleteDelete() {
    let count = speed;
    for (let y = 0; y < height; y++) {
        let x = 0;
        for ( ; x < width; x++) {
            if (data[y * width + x] === 0)
                break;
        }
        if (x == width) {
            shiftLines(y);
            y--;
            speed--;
        }
    }
    if (count - speed == 4)
        console.log("BOOM - Tetris for Jeff.");
}

///////////////////////////////////////////////////
// Effects (Background)
///////////////////////////////////////////////////
function updateEffect(minus) {
	effect.time += effect.direction * minus;

    if (effect.time <= -1) {
        effect.direction = 1;
        effect.time = -1 + minus;
    } else if (effect.time >= 1) {
        effect.direction = -1;
        effect.time = 1 - minus;
    }
}

///////////////////////////////////////////////////
// Initialize
///////////////////////////////////////////////////
let stone_pos_X = 0;
let stone_pos_Y = 0;
let t = 0;
let speed = 0;

function init(_speed = 40) {
    gameEnd = false;
    t = 0;
    // TODO Higher = slower
    speed = _speed;

    emitStone();
    addStoneToArray();
}

init();

///////////////////////////////////////////////////
// Callbacks
///////////////////////////////////////////////////
// For updating the stone position each interval
this.addFrameCallback(function(renderer, timestamp, time) {
    const minus = renderer.deltaTime * 0.01;
	updateEffect(minus);

    t += Math.round(renderer.deltaTime/0.016);
    if (t < speed) {
        return;
    }
    t = 0;

    if (checkBelowStone()) {
        deleteStoneFromArray();
        stone_pos_Y--;
        addStoneToArray();
    } else if (!gameOver()) {
        ifLineCompleteDelete();
        emitStone();
        addStoneToArray();
    } else {
        console.log("Game Over. You deleted " + (40 - speed) + " lines.");
        console.log("Press " + KEY_RESTART + " to restart.");
    }
});

///////////////////////////////////////////////////
// Parse Input
///////////////////////////////////////////////////
shaderboy.onKeyDown(function(event) {
    if (event.code == KEY_RESTART) {
        for (let y = 0; y < height; y++)
            clearLine(y);
        init();
    }

    if (gameEnd) {
        return;
    }

    // key actions
    // sounds had to be removed due to cors policy among other reasons
    switch (event.code) {
        case KEY_RIGHT:
            shiftStone(directions.right);
            break;
        case KEY_LEFT:
            shiftStone(directions.left);
            break;
        case KEY_DOWN:
            shiftStone(directions.down);
            break;
        case KEY_FULLDOWN:
            shiftStone(directions.downMax);
            break;
        case KEY_TLEFT:
            rotateStone(rotations.left);
            break;
        case KEY_TRIGHT:
            rotateStone(rotations.right);
            break;
    }
});

///////////////////////////////////////////////////
// Texture
///////////////////////////////////////////////////
const texture = this.gl().createTexture();

function addTexture(gl) {
    // Create a texture.
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // fill texture with 3x2 pixels
    const level = 0;
    const internalFormat = gl.LUMINANCE;
    const border = 0;
    const format = gl.LUMINANCE;
    const type = gl.UNSIGNED_BYTE;

    const alignment = 4;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);

    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border,
                  format, type, data);

    // set the filtering so we don't need mips and it's not filtered
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

addTexture(shaderboy.gl());

// Update Texture Data callback
this.addFrameCallback(function(renderer) {
    const gl = renderer.gl;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0,
                  gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
});
}
</script>
<script>
            shaderboy.create("render-canvas", `#version 300 es
precision mediump float;

/**
 * Author: René Warnking
 * Copyright 2019 René Warnking
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

///////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////
// 0 - Sphere
// 1 - Cubes (incorrect shadows)
#define OBJ_TYPE 0
// 0 - no debug
// 1 - position
// 2 - normal
// 3 - obj color
// 4 - shadow value
#define DEBUG 0

#define SHADOW_ITER_COUNT 10
#define MATERIAL_COUNT 8
#define MATERIAL_COUNT_F 8.0
#define BORDER_MAT 0

#define phong_ambient vec3(0.2)
#define phong_diffuse vec3(1.0)
#define phong_specular vec3(1.0)
#define phong_shine 16.0

#define PI 3.14159265359

///////////////////////////////////////////////////////////////////////////////
// constant variables
///////////////////////////////////////////////////////////////////////////////
const int MAX_MARCHING_STEPS = 255;
const int MAX_SHADOW_MARCHING_STEPS = 55;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.001;

///////////////////////////////////////////////////////////////////////////////
// uniforms
///////////////////////////////////////////////////////////////////////////////
uniform vec2 uResolution;
uniform float uTime;

// background effect
uniform float uEffectTime;

uniform vec3 uCameraPos;
uniform float uWidth;
uniform float uHeight;

uniform sampler2D uBoardTex;

out vec4 oColor;

float EFFECT_RADIUS = 1.0;

#if DEBUG == 5
vec3 debugVec = vec3(0.0);
#endif

///////////////////////////////////////////////////////////////////////////////
// structs
///////////////////////////////////////////////////////////////////////////////
struct material {
    vec3 color;
};

material materials[MATERIAL_COUNT] = material[](
    // material(vec3(1.0, 0.0, 0.0)), // BorderMaterial
    material(vec3(0.1, 0.2, 0.4)), // BorderMaterial
    material(vec3(0.8, 0.0, 0.1)),
    material(vec3(0.75, 1.0, 0.0)),
    material(vec3(0.1, 0.7, 0.1)),
    material(vec3(0.3, 0.8, 0.9)),
    material(vec3(0.0, 0.2, 0.9)),
    material(vec3(0.4, 0.0, 0.6)),
    material(vec3(1.0, 1.0, 1.0))
);

struct hit {
    vec3 obj_center;
    int mat_id;
    vec3 hit_p;
    vec3 dim;
} l_hit;

///////////////////////////////////////////////////////////////////////////////
// Helper Functions
///////////////////////////////////////////////////////////////////////////////
/**
 * Normalized direction to march in from the eye point for a single pixel.
 *
 * fieldOfView: vertical field of view in degrees
 * fragCoord: the x,y coordinate of the pixel in the output image
 */
vec3 rayDirection(float fieldOfView, vec2 fragCoord)
{
    vec2 xy = fragCoord - uResolution / 2.0;
    float z = uResolution.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

vec3 hslColor(float hue, float sat, float light)
{
    // satuartion = 1.0, light = 0.5
    float C = (1.0 - abs(2.0 * light - 1.0)) * sat;
    float X = C * (1.0 - abs(mod(hue / 60.0, 2.0) - 1.0));
    float M = light - C * 0.5;

    vec3 color = vec3(M);

    if (hue < 60.0) {
        color.r += C;
        color.g += X;
        color.b += 0.0;
    } else if (hue < 120.0) {
        color.r += X;
        color.g += C;
        color.b += 0.0;
    } else if (hue < 180.0) {
        color.r += 0.0;
        color.g += C;
        color.b += X;
    } else if (hue < 240.0) {
        color.g += 0.0;
        color.r += X;
        color.b += C;
    } else if (hue < 300.0) {
        color.r += X;
        color.g += 0.0;
        color.b += C;
    } else {
        color.r += C;
        color.g += 0.0;
        color.b += X;
    }
    return color;
}

vec3 rainbowColor(float sat, float light)
{
    float hue = sin(uTime * 0.25) * 180.0 + 180.0;

    return hslColor(hue, sat, light);
}

///////////////////////////////////////////////////////////////////////////////
// Signed Distance Functions
///////////////////////////////////////////////////////////////////////////////
float differenceSDF(float distA, float distB)
{
    return max(distA, -distB);
}

/**
 * Signed distance function for a sphere centered at the origin with radius 1.0;
 */
float sphereSDF(vec3 samplePoint, vec3 spherePos)
{
    return length(samplePoint - spherePos) - 0.5;
}

float boxSDF(vec3 samplePoint, vec3 boxPos, vec3 boxDim)
{
    vec3 q = abs(samplePoint - boxPos) - boxDim;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float borderSDF(vec3 samplePoint, float planeDist)
{
    float r1 = boxSDF(
        samplePoint,
        vec3(0.0, 0.0, planeDist),
        vec3(uWidth/2.0+1.0, uHeight/2.0+1.0, 0.5)
    );

	float r2 = boxSDF(
        samplePoint,
        vec3(0.0, 0.0, planeDist),
        vec3(uWidth/2.0, uHeight/2.0, 1.0)
    );

    return differenceSDF(r1, r2);
}

float effectSDF(vec3 p)
{
    float t = 2.5 * uEffectTime;
    // vec3 m = vec3(mod(abs(p.xyz), 5.0));
    float q = sin(t * p.x) * sin(t * p.y) * sin(t * p.z);
    return length(p - vec3(0.0, 0.0, -50.0)) - 7.5 + q;
}

///////////////////////////////////////////////////////////////////////////////
// Draw Parts
///////////////////////////////////////////////////////////////////////////////
float drawBorder(vec3 samplePoint, float planeDist)
{
    float min_d = MAX_DIST;
	float tmp = borderSDF(samplePoint, planeDist);

    if (min_d > tmp)
    {
        min_d = tmp;
        l_hit.obj_center = vec3(0.0, 0.0, planeDist);
        l_hit.hit_p = samplePoint;
        l_hit.mat_id = BORDER_MAT;
        l_hit.dim = vec3(uWidth/2.0+1.0, uHeight/2.0+1.0, 0.5);
    }

    return min_d;
}

float drawField(vec3 samplePoint, vec3 rayMul,
                mat3 materials, float planeDist, float dist)
{
	float min_d = dist;

    // TODO dont do a sample range but rather estimate where the ray would hit
    float sample_range = 1.0;
    for (float x = -sample_range; x <= sample_range; x++) {
        for (float y = -sample_range; y <= sample_range; y++) {

            float color = materials[int(x+1.0)][int(y+1.0)];
            if (color > 0.0)
            {
                vec3 stonePos = vec3(
                    floor(rayMul.x) + 0.5 + x,
                    floor(rayMul.y) + 0.5 + y,
                    planeDist
                );
#if OBJ_TYPE == 0
                float tmp_d = sphereSDF(samplePoint, stonePos);
#else
                float tmp_d = boxSDF(samplePoint, stonePos, vec3(0.5));
#endif
                if (tmp_d < min_d)
                {
                    min_d = tmp_d;
                    l_hit.obj_center = stonePos;
                    l_hit.mat_id = int(color * MATERIAL_COUNT_F) + 1;
                }
                // interestingly enough this does not improve but rather
                // decrease performance
                //if (min_d < EPSILON)
                //    return min_d;

            }
        }
    }
    l_hit.hit_p = samplePoint;
    return min_d;
}

float boundRaymarching(vec3 camera, vec3 ray, float planeDist)
{
    float min_d = MAX_DIST;
    float depth = 0.0;

    float z = planeDist / ray.z;
    vec3 rayMul = ray * z;

    if (round(rayMul.x - 0.5) <= round(uWidth / 2.0) &&
        round(rayMul.x + 0.5) >= -round(uWidth / 2.0) &&
        round(abs(rayMul.y) - 0.5) <= round(uHeight / 2.0) &&
        round(rayMul.y + 0.5) >= -round(uHeight / 2.0)
       )
    {
        ivec2 uv = ivec2(
    		int(rayMul.x + uWidth / 2.0),
    		int(rayMul.y + uHeight / 2.0)
    	);

        mat3 materials;
		// Since the area in which the stones need to be sampled is
        // smaller then the field we need an additional check
        if (rayMul.x < -uWidth / 2.0 || rayMul.y < -uHeight / 2.0)
        {
            materials = mat3(
                0, 0, 0,
                0, 0, 0,
                0, 0, 0
        	);
        } else {
            // TODO obacht - change this such that out of bounds get reduced
            ivec3 tmp = ivec3(-1, 0, 1);
            materials = mat3(
                texelFetch(uBoardTex, uv + tmp.xx, 0).x,
                texelFetch(uBoardTex, uv + tmp.xy, 0).x,
                texelFetch(uBoardTex, uv + tmp.xz, 0).x,
                texelFetch(uBoardTex, uv + tmp.yx, 0).x,
                texelFetch(uBoardTex, uv + tmp.yy, 0).x,
                texelFetch(uBoardTex, uv + tmp.yz, 0).x,
                texelFetch(uBoardTex, uv + tmp.zx, 0).x,
                texelFetch(uBoardTex, uv + tmp.zy, 0).x,
                texelFetch(uBoardTex, uv + tmp.zz, 0).x
            );
        }

        float dist = MAX_DIST;
        for (int i = 0; i < MAX_MARCHING_STEPS && depth < MAX_DIST; i++)
        {
            dist = drawBorder(camera + depth * ray, planeDist);
            dist = min(dist, drawField(
                camera + depth * ray, rayMul, materials, planeDist, dist
            ));
            if (dist < EPSILON)
                return 0.0;
            depth += dist;
        }
    }

    return MAX_DIST;
}

///////////////////////////////////////////////////////////////////////////////
// Lighting
///////////////////////////////////////////////////////////////////////////////
vec3 estimateNormal(vec3 p, vec3 position, int mat)
{
    if (mat == BORDER_MAT)
    {
        return normalize(vec3(
            borderSDF(vec3(p.x + EPSILON, p.y, p.z), position.z) -
            borderSDF(vec3(p.x - EPSILON, p.y, p.z), position.z),
            borderSDF(vec3(p.x, p.y + EPSILON, p.z), position.z) -
            borderSDF(vec3(p.x, p.y - EPSILON, p.z), position.z),
            borderSDF(vec3(p.x, p.y, p.z + EPSILON), position.z) -
            borderSDF(vec3(p.x, p.y, p.z - EPSILON), position.z)
        ));
    }
    else
    {
#if OBJ_TYPE == 0
        return normalize(vec3(
            sphereSDF(vec3(p.x + EPSILON, p.y, p.z), position) -
            sphereSDF(vec3(p.x - EPSILON, p.y, p.z), position),
            sphereSDF(vec3(p.x, p.y + EPSILON, p.z), position) -
            sphereSDF(vec3(p.x, p.y - EPSILON, p.z), position),
            sphereSDF(vec3(p.x, p.y, p.z + EPSILON), position) -
            sphereSDF(vec3(p.x, p.y, p.z - EPSILON), position)
        ));
#else
        return normalize(vec3(
            boxSDF(vec3(p.x + EPSILON, p.y, p.z), position, vec3(0.5)) -
            boxSDF(vec3(p.x - EPSILON, p.y, p.z), position, vec3(0.5)),
            boxSDF(vec3(p.x, p.y + EPSILON, p.z), position, vec3(0.5)) -
            boxSDF(vec3(p.x, p.y - EPSILON, p.z), position, vec3(0.5)),
            boxSDF(vec3(p.x, p.y, p.z + EPSILON), position, vec3(0.5)) -
            boxSDF(vec3(p.x, p.y, p.z - EPSILON), position, vec3(0.5))
        ));
#endif
    }
}

vec3 phongOfPoint(vec3 light_pos, vec3 cam_pos, vec3 hit_point, vec3 normal)
{
    vec3 light_dir = normalize(light_pos - hit_point);
    vec3 view_dir = normalize(cam_pos - hit_point);

    float light_intensity = max(dot(normal, light_dir), 0.0);

    if (light_intensity > 0.0)
    {
        vec3 diffuse = light_intensity * phong_diffuse;

        float specular_strength = 1.0;
        vec3 reflect_dir = reflect(-light_dir, normal);

        float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
        vec3 specular = specular_strength * spec * phong_specular;

        return diffuse + specular;
    }
	return vec3(0.0);
}

////////////////////////////////////////////////////////
// Shadows
////////////////////////////////////////////////////////
// http://www.cse.yorku.ca/~amana/research/grid.pdf
float shadowRaymarching(vec3 camera, vec3 ray, float planeDist, vec3 light_pos)
{
    float light_dist = length(light_pos - camera);
    vec2 dims = vec2(uWidth / 2.0, uHeight / 2.0);
	vec2 boxDims = vec2(1.0);

    vec2 start = camera.xy;
    vec2 end = light_pos.xy;

    // Direction from point on stone to the lightsource
    vec2 dir = end - start;

    // If distance to small adjust it to avoid division by 0
    // This is done componentwise to allow for axis aligned vectors (e.g. 1,0)
    if (dir.x <= EPSILON && dir.x >= -EPSILON)
        dir.x = EPSILON;
    if (dir.y <= EPSILON && dir.y >= -EPSILON)
        dir.y = EPSILON;
    // If distance short return early
    if (light_dist <= EPSILON)
        return light_dist;
    vec2 dirVec = normalize(dir);

    // Run a bresenham algorithm to iterate all stones on the path of the ray
    vec2 step = sign(dir);
    dirVec = abs(dirVec);

    // Calculate the distance from the start point
    // to the edges of a stonefield which could intersect the ray
    // This is dependend on the ray direction.
    vec2 tMax = fract(start);
    if (step.x > 0.0)
        tMax.x = boxDims.x - tMax.x;
    if (step.y > 0.0)
        tMax.y = boxDims.y - tMax.y;
    tMax /= dirVec;

    // Calculate the offset by which the point is moved to reach the next stonepos
    vec2 tDelta = boxDims / dirVec;

    // As long as the stepcount is not exceeded and the lightpos is not reached continue
    for (int steps = 0; (start.x * step.x < end.x * step.x || start.y * step.y < end.y * step.y) &&
         steps < SHADOW_ITER_COUNT; steps++)
    {
        // Advance the start position, this depends on the slope of the dirVec (lower first)
        // Increase the tDelta to switch direction as soon as necessary
        if (tMax.x < tMax.y)
        {
            tMax.x += tDelta.x;
            start.x += step.x;
        }
        else
        {
            tMax.y += tDelta.y;
            start.y += step.y;
        }

        // Use the position to calculate the texture coords
        // these need to be adjusted to be only positive
        ivec2 uv = ivec2(floor(start) + dims);

        float material = texelFetch(uBoardTex, uv, 0).x;
        // If the position is occupied check whether the ray actually hits this stone
        if (material > 0.0)
    	{
        	vec3 newPos = vec3(floor(start) + vec2(0.5), planeDist);

            float depth = 0.0;
            float dist = light_dist;
            // TODO max(boxdims) instead of lightdist?
            for (int i = 0; i < MAX_SHADOW_MARCHING_STEPS && depth < light_dist; i++)
            {

#if OBJ_TYPE == 0
            	dist = sphereSDF(camera + depth * ray, newPos);
#else
                dist = boxSDF(camera + depth * ray, newPos, vec3(0.5));
#endif
                // If the distance is small then the stone was hit
                // otherwise continue following the ray
                if (dist < EPSILON)
                    return 0.0;
                depth += dist;
            }
        }
    }

    // Nothing is in the path of the lightray and therefore no shadow is needed
    // TODO Adjust such that the smallest distance is returned (soft shadow)
    return light_dist;
}

float inShadow(vec3 collision, vec3 light_pos, vec3 normal, float planeDist) {
    // Dont forget to normalize!
    vec3 light_dir = normalize(light_pos - collision);
    float light_dist = length(light_pos - collision);

    // If we are at the backside then we are in the shadow
    if (max(dot(light_dir, normal), 0.0) == 0.0)
        return 1.0;

    float dist = shadowRaymarching(
        collision - normal * EPSILON,
        light_dir,
        planeDist,
        light_pos
    );

     // Not in shadow
    if (dist >= light_dist - EPSILON)
		return 0.0;
    // In shadow
    else
        return 1.0;

}

///////////////////////////////////////////////////////////////////////////////
// Background
///////////////////////////////////////////////////////////////////////////////
void drawBackground(vec3 camera, vec3 dir, vec3 light_pos)
{
    const vec2 h = vec2(EPSILON, 0.0);

    float dist = MAX_DIST;
    float depth = EPSILON;

    for (int i = 0; i < 400 && depth < MAX_DIST; i++)
    {
        dist = effectSDF(camera + dir * depth);
        if (dist < EPSILON)
        {
            vec3 point = camera + dir * depth;
            vec3 snorm = normalize(
                vec3(effectSDF(point+h.xyy) - effectSDF(point-h.xyy),
                     effectSDF(point+h.yxy) - effectSDF(point-h.yxy),
                     effectSDF(point+h.yyx) - effectSDF(point-h.yyx))
            );

            oColor.rgb = vec3(0.1) * (phong_ambient + phongOfPoint(
                light_pos, camera, point, snorm
            ));
            oColor.a = 1.0;
            return;
        }
        depth += dist;
    }
    float alpha = length(gl_FragCoord.xy / uResolution - vec2(0.5)) - 0.05;
    oColor = vec4(vec3(0.1), alpha);
}

///////////////////////////////////////////////////////////////////////////////
// Main
///////////////////////////////////////////////////////////////////////////////
void main()
{
    materials[0] = material(rainbowColor(0.8, 0.1));

    l_hit = hit(vec3(0.0), 0, vec3(0.0), vec3(0.0));
    vec3 camera = uCameraPos;
    float fieldOfView = 45.0;
    vec3 dir = rayDirection(fieldOfView, gl_FragCoord.xy);
    // TODO add similar effect for x
	float planeDist = -max(
        0.0,
        (uHeight + 3.0) / tan(radians(fieldOfView) * 0.5)
    );

    vec3 light_pos = vec3(
        sin(uTime) * uWidth / 2.0,
        cos(uTime) * uHeight / 2.0,
        planeDist + abs(sin(uTime * 0.75)) * 1.25 + 0.75
    );

    float dist = boundRaymarching(camera, dir, planeDist);
    if (dist >= MAX_DIST)
    {
		drawBackground(camera, dir, light_pos);
        return;
    }

    vec3 normal = estimateNormal(l_hit.hit_p, l_hit.obj_center, l_hit.mat_id);
    float sVal = inShadow(l_hit.hit_p, light_pos, normal, planeDist);

    vec3 light = phong_ambient;
    light += (1.0 - sVal) * phongOfPoint(
        light_pos,
        camera, l_hit.hit_p, normal
    );

    oColor = vec4(materials[l_hit.mat_id].color, 1.0);
    oColor.rgb *= light;

#if DEBUG == 1
    oColor.rgb = l_hit.hit_p;
#elif DEBUG == 2
    oColor.rgb = normal;
#elif DEBUG == 3
    oColor.rgb = materials[l_hit.mat_id].color;
#elif DEBUG == 4
    oColor.rgb = vec3(sVal);
#elif DEBUG == 5
    oColor.rgb = debugVec;
#endif
}`);
            shaderboy.init();
            external.call(shaderboy);
            shaderboy.run();
        </script>
</html>
